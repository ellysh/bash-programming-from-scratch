# Ответы

## Общая информация

##### Упражнение 1-1. Перевод чисел из BIN в HEX

{line-numbers: false}
```
* 10100110100110 = 0010 1001 1010 0110 = 2 9 A 6 = 29A6

* 1011000111010100010011 = 0010 1100 0111 0101 0001 0011 = 2 C 7 5 1 3 = 2C7513

* 1111101110001001010100110000000110101101 = 1111 1011 1000 1001 0101 0011 0000 0001 1010 1101 = F B 8 9 5 3 0 1 A D = FB895301AD
```

##### Упражнение 1-2. Перевод чисел из HEX в BIN

{line-numbers: false}
```
* FF00AB02 = F F 0 0 A B 0 2 = 1111 1111 0000 0000 1010 1011 0000 0010 = 11111111000000001010101100000010

* 7854AC1 = 7 8 5 4 A C 1 = 0111 1000 0101 0100 1010 1100 0001 = 111100001010100101011000001

* 1E5340ACB38 = 1 E 5 3 4 0 A C B 3 8 = 0001 1110 0101 0011 0100 0000 1010 1100 1011 0011 1000 = 11110010100110100000010101100101100111000
```

## Командный интерпретатор Bash

##### Упражнение 2-1. Шаблоны поиска

{line-numbers: false}
```
* README.md
```

Строка `00_README.txt` не подходит, потому что шаблон `*ME.??` ожидает два символа после точки. В варианте `README` вообще нет точки, и он тоже не подходит.

##### Упражнение 2-2. Шаблоны поиска

Шаблону поиска удовлетворяют три строки:

* `/usr/share/doc/openssl/IPAddressChoice_new.html`
* `/usr/share/doc_openssl/IPAddressChoice_new.html`
* `/doc/openssl`

Строка `doc/openssl` не соответствует шаблону `*/doc?openssl*`, потому что в ней нет символа `/` перед `doc`.

##### Упражнение 2-3. Поиск файлов утилитой find

Правильный ответ следующий:
{line-numbers: false, format: Bash}
```
find /usr -name "*.txt" -exec wc -l {} +
```

Чтобы найти все TXT файлы, подойдёт также команда:
{line-numbers: false, format: Bash}
```
find / -name "*.txt"
```

Но если вы попробуйте расширить её действием `wc -l`, никакого вывода не будет:
{line-numbers: false, format: Bash}
```
find / -name "*.txt" -exec wc -l {} +
```

Помните сообщение об ошибке, которое выводится при запуске `find` в корневом каталоге? Текст этого сообщения будет передаваться в команду `wc`. Дальше команда будет интерпретировать каждое слово в качестве пути до файла. Очевидно, что эти пути окажутся недействительными и `wc` завершится с ошибкой. Чтобы её избежать, запускать `find` надо в каталоге `/usr`. Все TXT файлы находятся в нём и будут найдены командой.

##### Упражнение 2-4. Поиск файлов утилитой grep

Информацию о лицензии приложений логично искать в системном каталоге с документацией `/usr/share/doc`.

Для поиска приложений с лицензией [GNU General Public License](https://ru.wikipedia.org/wiki/GNU_General_Public_License) воспользуемся строкой "General Public License":
{line-numbers: false, format: Bash}
```
grep -Rl "General Public License" /usr/share/doc
```

Также имеет смысл поискать в каталоге `/usr/share/licenses`:
{line-numbers: false, format: Bash}
```
grep -Rl "General Public License" /usr/share/licenses
```

В окружении MSYS2 есть два неспецифичных для Unix каталога установки `/mingw32` и `/mingw64`. Можно проверить и установленные в них программы:
{line-numbers: true, format: Bash}
```
grep -Rl "General Public License" /mingw32/share/doc
grep -Rl "General Public License" /mingw64/share
```

В случае лицензии MIT можно искать строку "MIT license" в тех же каталогах. Для Apache лицензии подойдёт строка "Apache license", а для BSD - "BSD license".

##### Упражнение 2-6. Работа с файлами и каталогами

Прежде всего создадим каталоги, куда будем копировать фотографии:
{line-numbers: true, format: Bash}
```
mkdir -p ~/photo/2019/11
mkdir -p ~/photo/2019/12
mkdir -p ~/photo/2020/01
```

Предположим, что все ваши фотографии хранятся в каталоге `D:\Photo`. У него могут быть подкаталоги, но для нашего упражнения это несущественно. С помощью команды `find` найдём все файлы, созданные в ноябре 2019 года. Для этого воспользуемся параметром `-newermt`:
{line-numbers: false, format: Bash}
```
find /d/Photo -type f -newermt 2019-11-01 ! -newermt 2019-12-01
```

Эта команда ищет файлы в каталоге `/d/Photo`, который соответствует пути `D:\Photo` в Windows окружении.

Первое выражение `-newermt 2019-11-01` означает выбрать все файлы, модифицированные начиная с 1 ноября 2019 года. Далее идёт выражение `! -newermt 2019-12-01`. Как вы помните, восклицательный знак означает отрицание. По аналогии с предыдущим выражением, `-newermt 2019-12-01` означает все файлы, модифицированные начиная с 1 декабря 2019 года. Между этими выражениями нет условия. В этом случае используется логическое И. В результате получится высказывание: файлы, созданные после 1 ноября 2019 года, но не позднее 30 ноября 2019 года. Другими словами: файлы за ноябрь месяц.

Теперь к нашей команде `find` добавим действие копирования файлов:
{line-numbers: false, format: Bash}
```
find /d/Photo -type f -newermt 2019-11-01 ! -newermt 2019-12-01 -exec cp {} ~/photo/2019/11 \;
```

В результате в каталог `~/photo/2019/11` будут скопированы файлы за ноябрь 2019 года. Выполним аналогичные команды для копирования фотографий за декабрь и январь:
{line-numbers: true, format: Bash}
```
find /d/Photo -type f -newermt 2019-12-01 ! -newermt 2020-01-01 -exec cp {} ~/photo/2019/12 \;
find /d/Photo -type f -newermt 2020-01-01 ! -newermt 2020-02-01 -exec cp {} ~/photo/2020/01 \;
```

Вы можете заменить команду копирования на переименование, если файлы в каталоге `D:\Photo` вам больше не нужны:
{line-numbers: true, format: Bash}
```
find /d/Photo -type f -newermt 2019-11-01 ! -newermt 2019-12-01 -exec mv {} ~/photo/2019/11 \;
find /d/Photo -type f -newermt 2019-12-01 ! -newermt 2020-01-01 -exec mv {} ~/photo/2019/12 \;
find /d/Photo -type f -newermt 2020-01-01 ! -newermt 2020-02-01 -exec mv {} ~/photo/2020/01 \;
```

Обратите внимание на масштабируемость такого решения. Независимо от количества файлов в каталоге `D:\Photo` для разделения их по месяцам, нужно всего три команды.

##### Упражнение 2-7. Использование конвейеров и перенаправления потоков ввода-вывода

Прежде всего разберёмся, как работает утилита `bsdtar`. Согласно её выводу `--help`, для создания [**архива**](https://ru.wikipedia.org/wiki/Архив_(информатика)) каталога необходимо передать опции `-c` и `-f`, а также имя архива. Например:
{line-numbers: false, format: Bash}
```
bsdtar -c -f test.tar test
```

Эта команда создаст архив с именем `test.tar`, в который поместит всё содержимое каталога `test`. Обратите внимание, что [сжатия](https://ru.wikipedia.org/wiki/Сжатие_данных) в результате этой команды не произойдёт. То есть архив будет занимать почти столько же места на диске, сколько и собранные в него файлы. Цели операций архивирования и сжатия различны. Первая нужна для удобства хранения и переноса большого числа файлов. Сжатие позволяет уменьшить объём, занимаемый данными на диске. Часто эти операции совмещают в одну.

Если вы хотите сжать полученный архив, добавьте опцию `-j`:
{line-numbers: false, format: Bash}
```
bsdtar -c -j -f test.tar.bz2 test
```

Обратите внимание, что все опции `-c`, `-j` и `-f` можно записать без пробелов:
{line-numbers: false, format: Bash}
```
bsdtar -cjf test.tar.bz2 test
```

Мы разобрались, как использовать `bsdtar`. Теперь пришло время написать команду для прохода по каталогу фотографий и созданию архива для каждого месяца. Чтобы найти все каталоги с месяцами, воспользуемся командой `find`:
{line-numbers: false, format: Bash}
```
find ~/photo -type d -path */2019/* -o -path */2020/*
```

Теперь перенаправим её вывод утилите `xargs`, которая сформирует вызов `bsdtar`:
{line-numbers: false, format: Bash}
```
find ~/photo -type d -path */2019/* -o -path */2020/* | xargs -I% bsdtar -cf %.tar %
```

Если необходимо сжатие, добавьте опцию `-j` в вызов `bsdtar`:
{line-numbers: false, format: Bash}
```
find ~/photo -type d -path */2019/* -o -path */2020/* | xargs -I% bsdtar -cjf %.tar.bz2 %
```

I> Учтите, что сжатие — это значительно более долгая операция чем архивация.

В данном случае мы воспользовались параметром `-I` команды `xargs`, чтобы указать место подстановки сформированных ею аргументов. В случае вызова утилиты `bsdtar` этих мест два: имя создаваемого архива и путь до каталога, который следует обработать.

Не забывайте про имена файлов, которые могут содержать символы перевода строки. Чтобы обработать их корректно, добавим опцию `-print0` в вызов утилиты `find`:
{line-numbers: false, format: Bash}
```
find ~/photo -type d -path */2019/* -o -path */2020/* -print0 | xargs -0 -I% bsdtar -cjf %.tar.bz2 %
```

Если вы хотите, чтобы архивы содержали только файлы без относительных путей (например `2019/11`), воспользуйтесь опцией `--strip-components` утилиты `bsdtar`:
{line-numbers: false, format: Bash}
```
find ~/photo -type d -path */2019/* -o -path */2020/* -print0 | xargs -0 -I% bsdtar --strip-components=3 -cjf %.tar.bz2 %
```

##### Упражнение 2-8. Использование логических операторов

Будем реализовывать наш алгоритм последовательно шаг за шагом. Первое действие — копирование файла README в домашний каталог пользователя:
{line-numbers: false, format: Bash}
```
cp /usr/share/doc/bash/README ~
```

Чтобы вывести результат этой команды в лог-файл, воспользуемся оператором `&&` и `echo`:
{line-numbers: false, format: Bash}
```
cp /usr/share/doc/bash/README ~ && echo "cp - OK" > result.log
```

Далее необходимо заархивировать скопированный файл. Для этого воспользуемся утилитой `bsdtar` или `tar`:
{line-numbers: false, format: Bash}
```
bsdtar -cjf ~/README.tar.bz2 ~/README
```

Выведем её результат аналогично с использованием оператора `&&` и команды `echo`:
{line-numbers: false, format: Bash}
```
bsdtar -cjf ~/README.tar.bz2 ~/README && echo "bsdtar - OK" >> result.log
```

Обратите внимание, что в данном случае `echo` дописывает в конец уже существующего лог-файла.

Как объединить получившиеся вызовы `cp` и `bsdtar`? Утилита `bsdtar` должна отработать только в случае успешного выполнения копирования. Значит, надо опять воспользоваться оператором `&&`. В результате получим следующую команду:
{line-numbers: false, format: Bash}
```
cp /usr/share/doc/bash/README ~ && echo "cp - OK" > result.log && bsdtar -cjf ~/README.tar.bz2 ~/README && echo "bsdtar - OK" >> result.log
```

Добавим к ней последнее действие — удаление файла `README`:
{line-numbers: false, format: Bash}
```
cp /usr/share/doc/bash/README ~ && echo "cp - OK" > ~/result.log && bsdtar -cjf ~/README.tar.bz2 ~/README && echo "bsdtar - OK" >> ~/result.log && rm ~/README && echo "rm - OK" >> ~/result.log
```

Если вы запустите эту команду и все действия выполнятся корректно, вы получите следующий вывод в файле `result.txt`:
{line-numbers: true}
```
cp - OK
bsdtar - OK
rm - OK
```

Согласитесь, что читать получившуюся команду неудобно. Её можно разбить на несколько строк несколькими способами. Bash разрешает перенос строки сразу после логических операторов:
{line-numbers: true, format: Bash}
```
cp /usr/share/doc/bash/README ~ && echo "cp - OK" > ~/result.log &&
bsdtar -cjf ~/README.tar.bz2 ~/README && echo "bsdtar - OK" >> ~/result.log &&
rm ~/README && echo "rm - OK" >> ~/result.log
```

Попробуйте скопировать эту команду в окно терминала и исполнить. Она должна отработать без ошибок.

Если в вашей команде нет логических операторов, вы можете воспользоваться символом обратный слэш `\`. В нашем случае для примера поставим его перед `&&`:
{line-numbers: true, format: Bash}
```
cp /usr/share/doc/bash/README ~ && echo "cp - OK" > ~/result.log \
&& bsdtar -cjf ~/README.tar.bz2 ~/README && echo "bsdtar - OK" >> ~/result.log \
&& rm ~/README && echo "rm - OK" >> ~/result.log
```

Обратный слэш вы можете вставлять в любое место команды. Важно, чтобы сразу после него шёл перевод строки.

## Разработка Bash скриптов

##### Упражнение 3-2. Использование полной формы подстановки параметров

Чтобы ограничить утилиту `find` поиском только в текущем каталоге, воспользуемся параметром `-maxdepth`. Тогда команда поиска файлов с расширением TXT будет выглядеть следующим образом:
{line-numbers: false, format: Bash}
```
find . -maxdepth 1 -type f -name "*.txt"
```

Добавим в неё действие копирования найденных файлов в домашний каталог пользователя:
{line-numbers: false, format: Bash}
```
find . -maxdepth 1 -type f -name "*.txt" -exec cp -t ~ {} \;
```

Поместим команду в скрипт с именем `txt-copy.sh`. Тогда мы сможем вызвать скрипт и передать ему желаемое действие: копирование или переименование. Проще всего будет передавать имя утилиты (`cp` или `mv`), которую следует вызвать для каждого найденного файла. В таком случае следующая команда будет выполнять копирование:
{line-numbers: false, format: Bash}
```
./txt-copy.sh cp
```

Для перемещения найденных файлов достаточно заменить `cp` на `mv`:
{line-numbers: false, format: Bash}
```
./txt-copy.sh mv
```

Первый параметр, переданный скрипту, сохраняется в перменной `$1`. Подставим её в наш вызов `find`:
{line-numbers: false, format: Bash}
```
find . -maxdepth 1 -type f -name "*.txt" -exec "$1" -t ~ {} \;
```

Теперь зададим значение по умолчанию. Благодаря этому, будет выполняться копирование, если позиционный параметр `$1` пустой. В итоге наш скрипт будет выглядеть так:
{line-numbers: true, format: Bash}
```
#!/bin/bash
find . -maxdepth 1 -type f -name "*.txt" -exec "${1:-cp}" -t ~ {} \;
```

##### Упражнение 3-4. Использование оператора if

Исходная команда выглядит следующих образом:
{line-numbers: false, format: Bash}
```
( grep -RlZ "123" target | xargs -0 cp -t . && echo "cp - OK" || ! echo "cp - FAILS" ) && ( grep -RLZ "123" target | xargs -0 rm && echo "rm - OK" || echo "rm - FAILS" )
```

Обратите внимание на отрицание вывода "cp - FAILS". Если бы не оно, мы могли бы разбить команду на два отдельных вызова. Но в данном случае выполнение прервётся, если первый `grep` не найдёт ни одного файла и команда `cp` не сможет отработать корректно. Поэтому, нам нужен вложенный `if-else` следующего вида:
{line-numbers: true, format: Bash}
```
if grep -RlZ "123" target | xargs -0 cp -t .
then
  echo "cp - OK"
  if grep -RLZ "123" target | xargs -0 rm
  then
    echo "rm - OK"
  else
    echo "rm - FAILS"
  fi
else
  echo "cp - FAILS"
fi
```

Если применить технику раннего возврата, мы получим следующее:
{line-numbers: true, format: Bash}
```
if ! grep -RlZ "123" target | xargs -0 cp -t .
then
  echo "cp - FAILS"
  exit 1
fi

echo "cp - OK"

if grep -RLZ "123" target | xargs -0 rm
then
  echo "rm - OK"
else
  echo "rm - FAILS"
fi
```

Благодаря отрицанию `!` результата работы первого `grep` и следующего далее в конвейере `cp`, мы можем завершить скрипт сразу же после ошибки.

##### Упражнение 3-5. Использование оператора `[[`

Чтобы вывести файлы, которыми отличаются два каталога, их сначала нужно найти. Для поиска воспользуемся утилитой `find`. Тогда поиск файлов в каталоге `dir1` будет выглядеть так:
{line-numbers: false, format: Bash}
```
find dir1 -type f
```

Вывод этой команды может выглядеть например так:
{line-numbers: false}
```
dir1/test3.txt
dir1/test1.txt
dir1/test2.txt
```

Теперь нам нужно добавить действие с помощью параметра `-exec`, в котором мы проверим существование всех найденных файлов в каталоге `dir2`. Но есть одна проблема — каталог `dir1`, который утилита `find` добавляет к именам найденных файлов. Самый простой способ решить эту проблему — перейти в каталог `dir1` и после этого запустить `find`:
{line-numbers: true, format: Bash}
```
cd dir1
find . -type f
```

Теперь вывод будет выглядеть так:
{line-numbers: false}
```
./test3.txt
./test1.txt
./test2.txt
```

Добавим действие `-exec` с проверкой того, что найденный файл присутствует в каталоге `dir2`:
{line-numbers: true, format: Bash}
```
cd dir1
find . -type f -exec test -e ../dir2/{} \;
```

Обратите внимание, что в этом случае мы вынужденны использовать команду `test`, а не `[[`. Дело в том, что встроенный интерпретатор `find` не умеет корректно обрабатывать Bash конструкцию `[[`.

Если проверка не прошла, то есть файла нет, будем выводить его имя. Для этого инвертируем нашу проверку `test` и добавим второе `-exec` действие, связанное логическим И с первым. В результате получим следующий скрипт:
{line-numbers: true, format: Bash}
```
cd dir1
find . -type f -exec test ! -e ../dir2/{} \; -a -exec echo {} \;
```

Добавим аналогичный вызов `find` для проверки файлов каталога `dir2`:
{line-numbers: true, format: Bash}
```
cd dir1
find . -type f -exec test ! -e ../dir2/{} \; -a -exec echo {} \;

cd ../dir2
find . -type f -exec test ! -e ../dir1/{} \; -a -exec echo {} \;
```

I> Мы написали скрипт сравнения каталогов исключительно в учебных целях. Не используйте его для реальных задач. Лучше применяйте специальную GNU утилиту `diff`.

##### Упражнение 3-6. Использование конструкции `case`

Реализуем скрипт для переключения между конфигурационными файлами с использованием [символьных ссылок](https://ru.wikipedia.org/wiki/Символическая_ссылка). Символьная ссылка — это файл специального типа, который вместо данных содержит указатель на другой файл или каталог системы.

К сожалению, в Unix-окружении, работающем на OS Windows, вместо создания символьной ссылки будет происходить копирование соответствующего файла или каталога. Однако, они будут создаваться корректно на ОС Linux и macOS. Главное преимущество символьной ссылки заключается в том, что при работе с её содержимым вы на самом деле работаете с файлом или каталогом, на который она указывает. Это значит, что все изменения произойдут над этим файлом или каталогом.

Алгоритм нашего скрипта выглядит следующим образом:

1. Удалить существующую символьную ссылку или файл по пути `~/.bashrc`.

2. Проверить опцию командной строки, переданную в скрипт.

3. В зависимости от опции создать символьную ссылку на файл `.bashrc-home` или `.bashrc-work`.

Следующий скрипт реализует алгоритм с помощью конструкции `case`:
{line-numbers: true, format: Bash}
```
#!/bin/bash

file="$1"

rm ~/.bashrc

case "$file" in
  "h")
    ln -s ~/.bashrc-home ~/.bashrc
    ;;

  "w")
    ln -s ~/.bashrc-work ~/.bashrc
    ;;

  *)
    echo "Указана недопустимая опция"
    ;; 
esac
```

С помощью опции, переданной через позиционный параметр `$1`, выбирается имя файла.

Обратите внимание, что команда создания символьной ссылки остаётся неизменной независимо от опции скрипта. Это верный признак того, что конструкцию `case` можно заменить на ассоциативный массив. Например, следующим образом:
{line-numbers: true, format: Bash}
```
#!/bin/bash

option="$1"

declare -A files=(
  ["h"]="~/.bashrc-home"
  ["w"]="~/.bashrc-work")

if [[ -z "$option" || ! -v files["$option"] ]]
then
  echo "Указана недопустимая опция"
  exit 1
fi

rm ~/.bashrc

ln -s "${files["$option"]}" ~/.bashrc
```

Здесь мы используем двойные кавычки при подстановке элемента массива `files`, потому что он является одним параметром в вызове утилиты `ln`. Таким образом мы решаем возможную проблему с пробелами в путях.

##### Упражнение 3-7. Арифметические действия в дополнительном коде

Результаты сложения однобайтовых целых:
{line-numbers: false}
```
* 79 + (-46) = 0100 1111 + 1101 0010 = 1 0010 0001 -> 0010 0000 = 33

* -97 + 96 = 1001 1111 + 0110 0000 = 1111 1111 -> 1111 1110 -> 1000 0001 = -1
```

Результат сложения двухбайтовых целых:
{line-numbers: false}
```
* 12868 + (-1219) = 0011 0010 0100 0100 + 1111 1011 0011 1101 = 1 0010 1101 1000 0001 -> 0010 1101 1000 0001 = 11649
```

Для проверки корректности перевода чисел в дополнительный код можно использовать [онлайн-калькулятор](https://planetcalc.com/747/)

##### Упражнение 3-8. Вычисление остатка от деления и modulo

{line-numbers: false}
```
* 1697 % 13
q = 1697 / 13 ~ 130.5385 ~ 130
r = 1697 - 13 * 130 = 7

* 1697 modulo 13
q = 1697 / 13 ~ 130.5385 ~ 130
r = 1697 - 13 * 130 = 7

* 772 % -45
q = 772 / -45 ~ -17.15556 ~ -17
r = 772 - (-45) * (-17) = 7

* 772 modulo -45
q = (772 / -45) - 1 ~ -18.15556 ~ -18
r = 772 - (-45) * (-18) = -38

* -568 % 12
q = -568 / 12 ~ -47.33333 ~ -47
r = -568 - 12 * (-47) = -4

* -568 modulo 12
q = (-568 / 12) - 1 ~ -48.33333 ~ -48
r = -568 - 12 * (-48) = 8

* -5437 % -17
q = -5437 / -17 ~ 319.8235 ~ 319
r = -5437 - (-17) * 319 = -14

* -5437 modulo -17
q = -5437 / -17 ~ 319.8235 ~ 319
r = -5437 - (-17) * 319 = -14
```

##### Упражнение 3-9. Вычисление побитового отрицания

Сначала вычислим побитовое отрицание для случая беззнаковых двухбайтовых целых.
{line-numbers: false}
```
 56 = 0000 0000 0011 1000
~56 = 1111 1111 1100 0111 = 65479

 1018 = 0000 0011 1111 1010
~1018 = 1111 1100 0000 0101 = 64517

 58362 = 1110 0011 1111 1010
~58362 = 0001 1100 0000 0101 = 7173
```

Если операция отрицания выполняется над знаковыми двухбайтовыми целыми, результаты будут отличаться.
{line-numbers: false}
```
 56 = 0000 0000 0011 1000
~56 = 1111 1111 1100 0111 -> 1000 0000 0011 1001 = -57

 1018 = 0000 0011 1111 1010
~1018 = 1111 1100 0000 0101 -> 1000 0011 1111 1011 = -1019
```

Число 58362 не может быть представлено в виде знакового двухбайтового целого из-за переполнения. Если записать соответствующие ему биты в переменную такого типа, мы получим -7174. Перевод этого числа в прямой код будет выглядеть следующим образом:
{line-numbers: false}
```
58362 = 1110 0011 1111 1010 -> 1001 1100 0000 0110 = -7174
```

Теперь выполним побитовое отрицание:
{line-numbers: false}
```
  -7174  = 1110 0011 1111 1010
~(-7174) = 0001 1100 0000 0101 = 7173
```

Вы можете проверить результаты побитового отрицания над знаковыми целыми с помощью следующих Bash команд:
{line-numbers: true, format: Bash}
```
$ echo $((~56))
-57
$ echo $((~1018))
-1019
$ echo $((~(-7174)))
7173
```

Проверить отрицание двухбайтового беззнакого целого 58362 с помощью Bash не получится. Интерпретатор сохранит эту переменную в знаковом четырёхбайтовом целом. Тогда в результате отрицания мы получим:
{line-numbers: true, format: Bash}
```
$ echo $((~58362))
-58363
```

##### Упражнение 3-10. Вычисление побитовых И, ИЛИ, исключающего ИЛИ

Вычислим битовые операции для случая беззнаковых двухбайтовый целых:
{line-numbers: false}
```
1122 & 908 = 0000 0100 0110 0010 & 0000 0011 1000 1100 = 0000 0000 000 0000 = 0

1122 | 908 = 0000 0100 0110 0010 | 0000 0011 1000 1100 = 0000 0111 1110 1110 = 2030

1122 ^ 908 = 0000 0100 0110 0010 ^ 0000 0011 1000 1100 = 0000 0111 1110 1110 = 2030


49608 & 33036 = 1100 0001 1100 1000 & 1000 0001 0000 1100 = 1000 0001 0000 1000 = 33032

49608 | 33036 = 1100 0001 1100 1000 | 1000 0001 0000 1100 = 1100 0001 1100 1100 = 49612

49608 ^ 33036 = 1100 0001 1100 1000 ^ 1000 0001 0000 1100 = 0100 0000 1100 0100 = 16580
```

Если целые знаковые, то результаты битовых операций для первой пары чисел 1122 и 908 будут теми же. Для второй пары, вычисление будет отличаться.

Сначала выясним значение обоих чисел в прямом коде:
{line-numbers: false}
```
49608 = 1100 0001 1100 1000 -> 1011 1110 0011 1000 = -15928

33036 = 1000 0001 0000 1100 -> 1111 1110 1111 0100 = -32500

-15928 & -32500 = 1100 0001 1100 1000 & 1000 0001 0000 1100 = 1000 0001 0000 1000 -> 1111 1110 1111 1000 = -32504

-15928 | -32500 = 1100 0001 1100 1000 | 1000 0001 0000 1100 = 1100 0001 1100 1100 -> 1011 1110 0011 0100 = -15924

-15928 ^ -32500 = 1100 0001 1100 1000 ^ 1000 0001 0000 1100 = 0100 0000 1100 0100 = 16580
```

Bash-команды для проверки результатов операций:
{line-numbers: true, format: Bash}
```
$ echo $((1122 & 908))
0
$ echo $((1122 | 908))
2030
$ echo $((1122 ^ 908))
2030

$ echo $((49608 & 33036))
33032
$ echo $((49608 | 33036))
49612
$ echo $((49608 ^ 33036))
16580

$ echo $((-15928 & -32500))
-32504
$ echo $((-15928 | -32500))
-15924
$ echo $((-15928 ^ -32500))
16580
```

##### Упражнение 3-11. Вычисление битовых сдвигов

Вычисление операций:
{line-numbers: false}
```
* 25649 >> 3 = 0110 0100 0011 0001 >> 3 = 0110 0100 0011 0 = 0000 1100 1000 0110 = 3206

* 25649 << 2 = 0110 0100 0011 0001 << 2 = 10 0100 0011 0001 -> 1001 0000 1100 0100 -> 1110 1111 0011 1100 = -28476

* -9154 >> 4 = 1101 1100 0011 1110 >> 4 = 1101 1100 0011 -> 1111 1101 1100 0011 -> 1000 0010 0011 1101 = -573

* -9154 << 3 = 1101 1100 0011 1110 << 3 = 1 1100 0011 1110 -> 1110 0001 1111 0000 -> 1001 1110 0001 0000 = -7696
```

Bash-команды для проверки результатов:
{line-numbers: true, format: Bash}
```
$ echo $((25649 >> 3))
3206
$ echo $((25649 << 2))
102596
$ echo $((-9154 >> 4))
-573
$ echo $((-9154 << 3))
-73232
```

Отличие результатов второй и четвёртой операции связано с восьмибайтовым представлением чисел в Bash.

Вы можете проверить свои расчёты также с помощью [онлайн-калькулятора](https://onlinetoolz.net/bitshift).

##### Упражнение 3-12. Использование операторов цикла

Согласно условию задачи, у игрока есть семь попыток отгадать число. Поэтому применим конструкцию `for` с фиксированным количеством итераций. На каждой итерации будем читать ввод пользователя с помощью команды `read`. Затем сравним введённое число с загаданным. В зависимости от результата будем выводить текст подсказки.

Чтобы загадать случайное число, воспользуемся зарезервированной переменной `RANDOM`. При чтении она возвращает случайное значение от 0 до 32767. В нашем случае требуется число от 1 до 100. Его можно получить из значения `RANDOM` за два шага. Прежде всего рассчитаем остаток от деления `RANDOM` на 100 по следующей формуле:
{line-numbers: false, format: Bash}
```
number=$((RANDOM % 100))
```

Таким образом мы получим случайное число от 0 до 99. Прибавим к нему единицу, чтобы получить нужный нам диапазон от 1 до 100. Конечная формула расчёта выглядит так:
{line-numbers: false, format: Bash}
```
number=$((RANDOM % 100 + 1))
```

Полное решение задачи выглядит следующим образом:
{line-numbers: true, format: Bash}
```
#!/bin/bash

number=$((RANDOM % 100 + 1))

for i in {1..7}
do
  echo "Введите число:"

  read input

  if (( input < number))
  then
    echo "Число $input меньше искомого"
  elif (( number < input))
  then
    echo "Число $input больше искомого"
  else
    echo "Вы отгадали число"
    exit 0
  fi  
done

echo "Вы не отгадали число"
```

Чтобы успешно отгадать число за семь попыток, вам необходимо применить [**алгоритм двоичного поиска**](https://ru.wikipedia.org/wiki/Двоичный_поиск). Его идея заключается в том, чтобы дробить массив чисел на половины. Рассмотрим пример одной игры "Больше-Меньше", в которой будем использовать этот алгоритм.

В самом начале игры мы ищем число в диапазоне от 1 до 100. Серединой этого диапазона является 50. Поэтому вводим это значение первым. Например, программа нам ответила, что 50 меньше искомого числа. Это значит, что оно находится в диапазоне от 50 до 100. Теперь вводим середину этого диапазона, то есть число 75. Получаем ответ, что 75 тоже меньше искомого. Вывод — искомое число находится между 75 и 100. Середина этого диапазона `x` рассчитывается следующим образом:
{line-numbers: false, format: text}
```
x = 75 + (100 - 75) / 2 = 87.5
``` 

Вы можете округлить результат в большую или меньшую сторону. Это неважно. Округлим в меньшую и получим число 87 для следующего ввода. Если число до сих пор не было отгадано, продолжаем делить диапазон возможных чисел пополам. В конце концов семи шагов должно хватить для поиска.

##### Упражнение 3-13. Использование функций

Вариант с оператором `case` уже был рассмотрен в примерах раздела "Функции в скриптах". Если мы объединим код функций `print_error` и `code_to_error` в один файл, то получим следующее:
{line-numbers: true, format: Bash}
```
#!/bin/bash

code_to_error()
{
  case $1 in
    1)
      echo "Не найден файл"
      ;;
    2)
      echo "Нет прав для чтения файла"
      ;;
  esac
}

print_error()
{
  echo "$(code_to_error $1) $2" >> debug.log
}

print_error 1 "readme.txt"
```

Переименуем функцию `code_to_error` на `code_to_error_ru`, чтобы её имя отражало язык возвращаемых сообщений.

Далее дополним скрипт функцией `code_to_error_en`, которая будет возвращать текст на английском языке для соответствующего кода ошибки. Эта функция может выглядеть следующим образом:
{line-numbers: true, format: Bash}
```
code_to_error_en()
{
  case $1 in
    1)
      echo "The following file was not found:"
      ;;
    2)
      echo "You do not have permissions to read the following file:"
      ;;
  esac
}
```

Теперь нам необходимо выбрать, какую функцию `code_to_error_ru` или `code_to_error_en` вызывать в `print_error`. Для этого будем проверять значение переменной окружения `LANG`. Региональные настройки пользовательского интерфейса хранятся в ней. Тогда полный скрипт будет выглядеть следующим образом:
{line-numbers: true, format: Bash}
```
#!/bin/bash

code_to_error_ru()
{
  case $1 in
    1)
      echo "Не найден файл"
      ;;
    2)
      echo "Нет прав для чтения файла"
      ;;
  esac
}

code_to_error_en()
{
  case $1 in
    1)
      echo "The following file was not found:"
      ;;
    2)
      echo "You do not have permissions to read the following file:"
      ;;
  esac
}

print_error()
{
  if [[ "$LANG" == ru_RU* ]]
  then
    echo "$(code_to_error_ru $1) $2" >> debug.log
  else
    echo "$(code_to_error_en $1) $2" >> debug.log
  fi
}

print_error 1 "readme.txt"
```

Если язык системы русский, в переменной `LANG` встретиться шаблон `ru_Ru*`. В этом случае вызывается функция `code_to_error_ru`. В любом другом случае вызывается `code_to_error_en`.

Конструкцию `if` в функции `print_error` можно заменить на `case`. Например, следующим образом:
{line-numbers: true, format: Bash}
```
print_error()
{
  case $LANG in
    ru_RU*)
      echo "$(code_to_error_ru $1) $2" >> debug.log
      ;;
    en_US*)
      echo "$(code_to_error_en $1) $2" >> debug.log
      ;;
    *)
      echo "$(code_to_error_en $1) $2" >> debug.log
      ;;
  esac
}
```

Вариант с `case` будет удобнее, если необходимо поддерживать более двух языков.

В функции `print_error` происходит дублирование кода. В каждом блоке конструкции `case` выполняется одна и та же команда `echo`. Единственное различие между блоками — это вызываемая функция для конвертирования кода ошибки в текст. Чтобы избежать дублирования, воспользуемся переменной `func`, которая будет хранить имя функции для конвертирования. Получим следующий результат:
{line-numbers: true, format: Bash}
```
print_error()
{
  case $LANG in
    ru_RU)
      local func="code_to_error_ru"
      ;;
    en_US)
      local func="code_to_error_en"
      ;;
    *)
      local func="code_to_error_en"
      ;;
  esac

  echo "$($func $1) $2" >> debug.log
}
```

Конструкции `case` в функциях `code_to_error_ru` и `code_to_error_en` можно заменить на индексируемые массивы. Например, следующим образом:
{line-numbers: true, format: Bash}
```
code_to_error_ru()
{
  declare -a messages

  messages[1]="Не найден файл"
  messages[2]="Нет прав для чтения файла"

  echo "${messages[$1]}"
}

code_to_error_en()
{
  declare -a messages

  messages[1]="The following file was not found:"
  messages[2]="You do not have permissions to read the following file:"

  echo "${messages[$1]}"
}
```

На самом деле можно сделать один ассоциативный массив, в котором будут собраны все языки и сообщения. В качестве ключа в таком массиве может использоваться комбинация значения переменной `LANGUAGE` и кода сообщения. В результате мы сможем обойтись только одной функцией `print_error`:
{line-numbers: true, format: Bash}
```
#!/bin/bash

print_error()
{
  declare -A messages

  messages["ru_RU",1]="Не найден файл"
  messages["ru_RU",2]="Нет прав для чтения файла"

  messages["en_US",1]="The following file was not found:"
  messages["en_US",2]="You do not have permissions to read the          following file:"

  echo "${messages[$LANGUAGE,$1]} $2" >> debug.log
}

print_error 1 "readme.txt"
```

##### Упражнение 3-14. Область видимости переменных

После выполнения скрипта из листинга 3-36 на консоль будет выведен следующий текст:
{line-numbers: true, format: text}
```
main1: var =
foo1: var = foo_value
bar1: var = foo_value
bar2: var = bar_value
foo2: var = bar_value
main2: var = 
```

Начнём с самого простого вывода "main1" и "main2". Переменная `var` объявлена в функции `foo`. Поэтому она доступна только в ней и в вызываемой из неё функции `bar`. Следовательно, до и после вызова `foo` переменная считается необъявленной.

В выводе "foo1" мы получили только что присвоенное переменной значение `foo_value`. Далее идёт вывод "bar1". Переменная `var` была объявлена в функции `foo`, а `bar` вызывается из неё. Поэтому тело функции `bar` также является областью видимости `var`.

Затем мы присваиваем `var` новое значение `bar_value`. Обратите внимание, что здесь происходит не объявление новой глобальной переменной с именем `var`, а перезапись уже существующей локальной переменной. Поэтому в выводах "bar2" и в "foo2" мы увидим новое значение `bar_value`. Также именно по этой причине мы не увидим значение переменной в выводе "main2".